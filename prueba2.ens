
;-----------------------------------------------------------------------------------------
                        ORG 0
                        MOVE .SP, .IX ; initialize IX to point to the start of the stack
                        MOVE #static_memory_start, .IY               ;  intialize IY to point to the start of the static memory
                        BR $nombre_end                               ;  jump to the end of the function to avoid calling it 
nombre:
                        NOP                                          ;  NOP to manage recursive functions
;empieza asignacion de string
                        MOVE #lit0, .R5                              ;  poner en .R5 la direccion de LECTURA
                        ADD #64, .IY                                 
                        MOVE .A, .R6                                 ;  poner en R6 la direccion de ESCRITURA
                        MOVE #0, .R7                                 ;  r7 = contador para salir del bucle de asignacion de strings
                                                                     ;  copiar los datos de op1 a res
copy_0_loop:
                        MOVE [.R5], [.R6]                            ;  #offset[/op1] -> #offset[/res]
                        INC .R5                                      ;  aumentamos la posicion de la que leemos
                        INC .R6                                      ;   aumentamos la posicion en la que escribimos
                        INC .R7                                      ;  aumentamos el contador del bucle
                        CMP #4 , .R7                                 
                        BP /copy_0_loop                              ;  si R7 <63 repites el bucle
;termina asignacion de string
;conmienzo return
                        MOVE #64[.IY] , .R5                          ;  None
                        BR [.IX]                                     ;  devuelve el control al llamador
;fin return
                        BR [.IX]                                     ;  devuelve el control al llamador
nombre_end:
                        NOP                                          ;  para evitar 2 tags juntos
; empieza paso de parámetro 0
                        ADD #0, .IX                                  ;  movemos el puntero al siguiente RA
                        ADD #1, .A                                   ;  Nos colocamos en la parte de params del RA del llamado
                        MOVE #2 , [.A]                               ;   Pasamos el param a su posicion, la suma anterior incrementa por cada param
;fin de paso de parametro 0
;empieza llamda a nombre() 
                        ADD #0, .IX                                  ;  avanzo el puntero de pila al RA de la funcion llamada   
                        MOVE .A, .IX                                 ;  recoloco el puntero de pila al comienzo del resgistro de activacion al llamado
                        MOVE #ret_dir_nombre_0, [.IX]                ;  coloco la dirección del salto de retorno en el EM del RA de la funcion llamada 
                        BR /nombre                                   ;  salto al codigo de la funcion llamada
ret_dir_nombre_0: 
                        SUB .IX, #0                                  
                        MOVE .A, .IX                                 ;  recolocamos el puntero de pila en el EM del llamado
                        ADD #0, .IX                                  
; nosotros en .R6 tenemos que dejar la direccion donde copiarlo, esto nuestro RA : EM + param + locales 
                        MOVE .A, .R6                                 ;  poner en R6 la direccion de ESCRITURA
                                                                     ;  llamado deja en .R5 la direccion del valor de retorno = direccion de LECTURA
                        MOVE #0, .R7                                 ;  r7 = contador para salir del bucle de asignacion de strings
                                                                     ;  copiar los datos de op1 a res
copy_1_loop:
                        MOVE [.R5], [.R6]                            ;  #offset[/op1] -> #offset[/res]
                        INC .R5                                      ;  aumentamos la posicion de la que leemos
                        INC .R6                                      ;   aumentamos la posicion en la que escribimos
                        INC .R7                                      ;  aumentamos el contador del bucle
                        CMP #62 , .R7                                
                        BP /copy_1_loop                              ;  si R7 <63 repites el bucle
;fin llamada a nombre() 
;empieza asignacion de string
                        ADD #0, .IX                                  
                        MOVE .A, .R5                                 ;  poner en R5 la direccion de LECTURA
                        ADD #0, .IY                                  
                        MOVE .A, .R6                                 ;  poner en R6 la direccion de ESCRITURA
                        MOVE #0, .R7                                 ;  r7 = contador para salir del bucle de asignacion de strings
                                                                     ;  copiar los datos de op1 a res
copy_2_loop:
                        MOVE [.R5], [.R6]                            ;  #offset[/op1] -> #offset[/res]
                        INC .R5                                      ;  aumentamos la posicion de la que leemos
                        INC .R6                                      ;   aumentamos la posicion en la que escribimos
                        INC .R7                                      ;  aumentamos el contador del bucle
                        CMP #62 , .R7                                
                        BP /copy_2_loop                              ;  si R7 <63 repites el bucle
;termina asignacion de string
                        WRSTR #64[.IY]                               ;   print string
                        WRSTR #0[.IY]                                ;   print string

                        HALT
                        NOP
                        lit0: DATA "abcd"                            
static_memory_start:
                        RES 128                                      ;  reserve 128 memory addresses for global variables
                        END                                          ; end of program
                
;----------------------------------------------------------------------------------------
    